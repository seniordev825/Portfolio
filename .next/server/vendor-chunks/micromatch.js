"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromatch";
exports.ids = ["vendor-chunks/micromatch"];
exports.modules = {

/***/ "(rsc)/./node_modules/micromatch/index.js":
/*!******************************************!*\
  !*** ./node_modules/micromatch/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst braces = __webpack_require__(/*! braces */ \"(rsc)/./node_modules/braces/index.js\");\nconst picomatch = __webpack_require__(/*! picomatch */ \"(rsc)/./node_modules/picomatch/index.js\");\nconst utils = __webpack_require__(/*! picomatch/lib/utils */ \"(rsc)/./node_modules/picomatch/lib/utils.js\");\nconst isEmptyString = (val)=>val === \"\" || val === \"./\";\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} `list` List of strings to match.\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */ const micromatch = (list, patterns, options)=>{\n    patterns = [].concat(patterns);\n    list = [].concat(list);\n    let omit = new Set();\n    let keep = new Set();\n    let items = new Set();\n    let negatives = 0;\n    let onResult = (state)=>{\n        items.add(state.output);\n        if (options && options.onResult) {\n            options.onResult(state);\n        }\n    };\n    for(let i = 0; i < patterns.length; i++){\n        let isMatch = picomatch(String(patterns[i]), {\n            ...options,\n            onResult\n        }, true);\n        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n        if (negated) negatives++;\n        for (let item of list){\n            let matched = isMatch(item, true);\n            let match = negated ? !matched.isMatch : matched.isMatch;\n            if (!match) continue;\n            if (negated) {\n                omit.add(matched.output);\n            } else {\n                omit.delete(matched.output);\n                keep.add(matched.output);\n            }\n        }\n    }\n    let result = negatives === patterns.length ? [\n        ...items\n    ] : [\n        ...keep\n    ];\n    let matches = result.filter((item)=>!omit.has(item));\n    if (options && matches.length === 0) {\n        if (options.failglob === true) {\n            throw new Error(`No matches found for \"${patterns.join(\", \")}\"`);\n        }\n        if (options.nonull === true || options.nullglob === true) {\n            return options.unescape ? patterns.map((p)=>p.replace(/\\\\/g, \"\")) : patterns;\n        }\n    }\n    return matches;\n};\n/**\n * Backwards compatibility\n */ micromatch.match = micromatch;\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */ micromatch.matcher = (pattern, options)=>picomatch(pattern, options);\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `[options]` See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */ micromatch.isMatch = (str, patterns, options)=>picomatch(patterns, options)(str);\n/**\n * Backwards compatibility\n */ micromatch.any = micromatch.isMatch;\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */ micromatch.not = (list, patterns, options = {})=>{\n    patterns = [].concat(patterns).map(String);\n    let result = new Set();\n    let items = [];\n    let onResult = (state)=>{\n        if (options.onResult) options.onResult(state);\n        items.push(state.output);\n    };\n    let matches = new Set(micromatch(list, patterns, {\n        ...options,\n        onResult\n    }));\n    for (let item of items){\n        if (!matches.has(item)) {\n            result.add(item);\n        }\n    }\n    return [\n        ...result\n    ];\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\n * @api public\n */ micromatch.contains = (str, pattern, options)=>{\n    if (typeof str !== \"string\") {\n        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n    }\n    if (Array.isArray(pattern)) {\n        return pattern.some((p)=>micromatch.contains(str, p, options));\n    }\n    if (typeof pattern === \"string\") {\n        if (isEmptyString(str) || isEmptyString(pattern)) {\n            return false;\n        }\n        if (str.includes(pattern) || str.startsWith(\"./\") && str.slice(2).includes(pattern)) {\n            return true;\n        }\n    }\n    return micromatch.isMatch(str, pattern, {\n        ...options,\n        contains: true\n    });\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */ micromatch.matchKeys = (obj, patterns, options)=>{\n    if (!utils.isObject(obj)) {\n        throw new TypeError(\"Expected the first argument to be an object\");\n    }\n    let keys = micromatch(Object.keys(obj), patterns, options);\n    let res = {};\n    for (let key of keys)res[key] = obj[key];\n    return res;\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\n * @api public\n */ micromatch.some = (list, patterns, options)=>{\n    let items = [].concat(list);\n    for (let pattern of [].concat(patterns)){\n        let isMatch = picomatch(String(pattern), options);\n        if (items.some((item)=>isMatch(item))) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\n * @api public\n */ micromatch.every = (list, patterns, options)=>{\n    let items = [].concat(list);\n    for (let pattern of [].concat(patterns)){\n        let isMatch = picomatch(String(pattern), options);\n        if (!items.every((item)=>isMatch(item))) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */ micromatch.all = (str, patterns, options)=>{\n    if (typeof str !== \"string\") {\n        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n    }\n    return [].concat(patterns).every((p)=>picomatch(p, options)(str));\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */ micromatch.capture = (glob, input, options)=>{\n    let posix = utils.isWindows(options);\n    let regex = picomatch.makeRe(String(glob), {\n        ...options,\n        capture: true\n    });\n    let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n    if (match) {\n        return match.slice(1).map((v)=>v === void 0 ? \"\" : v);\n    }\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */ micromatch.makeRe = (...args)=>picomatch.makeRe(...args);\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */ micromatch.scan = (...args)=>picomatch.scan(...args);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.parse(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */ micromatch.parse = (patterns, options)=>{\n    let res = [];\n    for (let pattern of [].concat(patterns || [])){\n        for (let str of braces(String(pattern), options)){\n            res.push(picomatch.parse(str, options));\n        }\n    }\n    return res;\n};\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */ micromatch.braces = (pattern, options)=>{\n    if (typeof pattern !== \"string\") throw new TypeError(\"Expected a string\");\n    if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n        return [\n            pattern\n        ];\n    }\n    return braces(pattern, options);\n};\n/**\n * Expand braces\n */ micromatch.braceExpand = (pattern, options)=>{\n    if (typeof pattern !== \"string\") throw new TypeError(\"Expected a string\");\n    return micromatch.braces(pattern, {\n        ...options,\n        expand: true\n    });\n};\n/**\n * Expose micromatch\n */ module.exports = micromatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWljcm9tYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1HLFFBQVFILG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1JLGdCQUFnQkMsQ0FBQUEsTUFBT0EsUUFBUSxNQUFNQSxRQUFRO0FBRW5EOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBRUQsTUFBTUMsYUFBYSxDQUFDQyxNQUFNQyxVQUFVQztJQUNsQ0QsV0FBVyxFQUFFLENBQUNFLE1BQU0sQ0FBQ0Y7SUFDckJELE9BQU8sRUFBRSxDQUFDRyxNQUFNLENBQUNIO0lBRWpCLElBQUlJLE9BQU8sSUFBSUM7SUFDZixJQUFJQyxPQUFPLElBQUlEO0lBQ2YsSUFBSUUsUUFBUSxJQUFJRjtJQUNoQixJQUFJRyxZQUFZO0lBRWhCLElBQUlDLFdBQVdDLENBQUFBO1FBQ2JILE1BQU1JLEdBQUcsQ0FBQ0QsTUFBTUUsTUFBTTtRQUN0QixJQUFJVixXQUFXQSxRQUFRTyxRQUFRLEVBQUU7WUFDL0JQLFFBQVFPLFFBQVEsQ0FBQ0M7UUFDbkI7SUFDRjtJQUVBLElBQUssSUFBSUcsSUFBSSxHQUFHQSxJQUFJWixTQUFTYSxNQUFNLEVBQUVELElBQUs7UUFDeEMsSUFBSUUsVUFBVXBCLFVBQVVxQixPQUFPZixRQUFRLENBQUNZLEVBQUUsR0FBRztZQUFFLEdBQUdYLE9BQU87WUFBRU87UUFBUyxHQUFHO1FBQ3ZFLElBQUlRLFVBQVVGLFFBQVFMLEtBQUssQ0FBQ08sT0FBTyxJQUFJRixRQUFRTCxLQUFLLENBQUNRLGNBQWM7UUFDbkUsSUFBSUQsU0FBU1Q7UUFFYixLQUFLLElBQUlXLFFBQVFuQixLQUFNO1lBQ3JCLElBQUlvQixVQUFVTCxRQUFRSSxNQUFNO1lBRTVCLElBQUlFLFFBQVFKLFVBQVUsQ0FBQ0cs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LFVBQVV1RSxNQUFNLElBQUlJO0FBRXJEOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVEdkUsV0FBV3dFLElBQUksR0FBRyxDQUFDLEdBQUdELE9BQVMzRSxVQUFVNEUsSUFBSSxJQUFJRDtBQUVqRDs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRHZFLFdBQVd5RSxLQUFLLEdBQUcsQ0FBQ3ZFLFVBQVVDO0lBQzVCLElBQUlzRCxNQUFNLEVBQUU7SUFDWixLQUFLLElBQUluQixXQUFXLEVBQUUsQ0FBQ2xDLE1BQU0sQ0FBQ0YsWUFBWSxFQUFFLEVBQUc7UUFDN0MsS0FBSyxJQUFJcUMsT0FBTzVDLE9BQU9zQixPQUFPcUIsVUFBVW5DLFNBQVU7WUFDaERzRCxJQUFJZixJQUFJLENBQUM5QyxVQUFVNkUsS0FBSyxDQUFDbEMsS0FBS3BDO1FBQ2hDO0lBQ0Y7SUFDQSxPQUFPc0Q7QUFDVDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUVEekQsV0FBV0wsTUFBTSxHQUFHLENBQUMyQyxTQUFTbkM7SUFDNUIsSUFBSSxPQUFPbUMsWUFBWSxVQUFVLE1BQU0sSUFBSU0sVUFBVTtJQUNyRCxJQUFJLFdBQVl6QyxRQUFRdUUsT0FBTyxLQUFLLFFBQVMsQ0FBQyxTQUFTQyxJQUFJLENBQUNyQyxVQUFVO1FBQ3BFLE9BQU87WUFBQ0E7U0FBUTtJQUNsQjtJQUNBLE9BQU8zQyxPQUFPMkMsU0FBU25DO0FBQ3pCO0FBRUE7O0NBRUMsR0FFREgsV0FBVzRFLFdBQVcsR0FBRyxDQUFDdEMsU0FBU25DO0lBQ2pDLElBQUksT0FBT21DLFlBQVksVUFBVSxNQUFNLElBQUlNLFVBQVU7SUFDckQsT0FBTzVDLFdBQVdMLE1BQU0sQ0FBQzJDLFNBQVM7UUFBRSxHQUFHbkMsT0FBTztRQUFFMEUsUUFBUTtJQUFLO0FBQy9EO0FBRUE7O0NBRUMsR0FFREMsT0FBT0MsT0FBTyxHQUFHL0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbWljcm9tYXRjaC9pbmRleC5qcz9iNGJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGJyYWNlcyA9IHJlcXVpcmUoJ2JyYWNlcycpO1xuY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJ3BpY29tYXRjaC9saWIvdXRpbHMnKTtcbmNvbnN0IGlzRW1wdHlTdHJpbmcgPSB2YWwgPT4gdmFsID09PSAnJyB8fCB2YWwgPT09ICcuLyc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgbWF0Y2ggb25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiAvLyBtbShsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbShbJ2EuanMnLCAnYS50eHQnXSwgWycqLmpzJ10pKTtcbiAqIC8vPT4gWyAnYS5qcycgXVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheTxzdHJpbmc+fSBgbGlzdGAgTGlzdCBvZiBzdHJpbmdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXk8c3RyaW5nPn0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKVxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlc1xuICogQHN1bW1hcnkgZmFsc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY29uc3QgbWljcm9tYXRjaCA9IChsaXN0LCBwYXR0ZXJucywgb3B0aW9ucykgPT4ge1xuICBwYXR0ZXJucyA9IFtdLmNvbmNhdChwYXR0ZXJucyk7XG4gIGxpc3QgPSBbXS5jb25jYXQobGlzdCk7XG5cbiAgbGV0IG9taXQgPSBuZXcgU2V0KCk7XG4gIGxldCBrZWVwID0gbmV3IFNldCgpO1xuICBsZXQgaXRlbXMgPSBuZXcgU2V0KCk7XG4gIGxldCBuZWdhdGl2ZXMgPSAwO1xuXG4gIGxldCBvblJlc3VsdCA9IHN0YXRlID0+IHtcbiAgICBpdGVtcy5hZGQoc3RhdGUub3V0cHV0KTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9uUmVzdWx0KSB7XG4gICAgICBvcHRpb25zLm9uUmVzdWx0KHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBpc01hdGNoID0gcGljb21hdGNoKFN0cmluZyhwYXR0ZXJuc1tpXSksIHsgLi4ub3B0aW9ucywgb25SZXN1bHQgfSwgdHJ1ZSk7XG4gICAgbGV0IG5lZ2F0ZWQgPSBpc01hdGNoLnN0YXRlLm5lZ2F0ZWQgfHwgaXNNYXRjaC5zdGF0ZS5uZWdhdGVkRXh0Z2xvYjtcbiAgICBpZiAobmVnYXRlZCkgbmVnYXRpdmVzKys7XG5cbiAgICBmb3IgKGxldCBpdGVtIG9mIGxpc3QpIHtcbiAgICAgIGxldCBtYXRjaGVkID0gaXNNYXRjaChpdGVtLCB0cnVlKTtcblxuICAgICAgbGV0IG1hdGNoID0gbmVnYXRlZCA/ICFtYXRjaGVkLmlzTWF0Y2ggOiBtYXRjaGVkLmlzTWF0Y2g7XG4gICAgICBpZiAoIW1hdGNoKSBjb250aW51ZTtcblxuICAgICAgaWYgKG5lZ2F0ZWQpIHtcbiAgICAgICAgb21pdC5hZGQobWF0Y2hlZC5vdXRwdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb21pdC5kZWxldGUobWF0Y2hlZC5vdXRwdXQpO1xuICAgICAgICBrZWVwLmFkZChtYXRjaGVkLm91dHB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlc3VsdCA9IG5lZ2F0aXZlcyA9PT0gcGF0dGVybnMubGVuZ3RoID8gWy4uLml0ZW1zXSA6IFsuLi5rZWVwXTtcbiAgbGV0IG1hdGNoZXMgPSByZXN1bHQuZmlsdGVyKGl0ZW0gPT4gIW9taXQuaGFzKGl0ZW0pKTtcblxuICBpZiAob3B0aW9ucyAmJiBtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChvcHRpb25zLmZhaWxnbG9iID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoZXMgZm91bmQgZm9yIFwiJHtwYXR0ZXJucy5qb2luKCcsICcpfVwiYCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9udWxsID09PSB0cnVlIHx8IG9wdGlvbnMubnVsbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnVuZXNjYXBlID8gcGF0dGVybnMubWFwKHAgPT4gcC5yZXBsYWNlKC9cXFxcL2csICcnKSkgOiBwYXR0ZXJucztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbi8qKlxuICogQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqL1xuXG5taWNyb21hdGNoLm1hdGNoID0gbWljcm9tYXRjaDtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbiBmcm9tIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuYCBhbmQgYG9wdGlvbnNgLlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIGEgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBvbmx5IGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBtYXRjaC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbW0gPSByZXF1aXJlKCdtaWNyb21hdGNoJyk7XG4gKiAvLyBtbS5tYXRjaGVyKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc3QgaXNNYXRjaCA9IG1tLm1hdGNoZXIoJyouISgqYSknKTtcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYScpKTsgLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5iJykpOyAvLz0+IHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBHbG9iIHBhdHRlcm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5tYXRjaGVyID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IHBpY29tYXRjaChwYXR0ZXJuLCBvcHRpb25zKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgKiphbnkqKiBvZiB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgIG1hdGNoIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0uaXNNYXRjaChzdHJpbmcsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmlzTWF0Y2goJ2EuYScsIFsnYi4qJywgJyouYSddKSk7IC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2cobW0uaXNNYXRjaCgnYS5hJywgJ2IuKicpKTsgLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmAgVGhlIHN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBbb3B0aW9uc11gIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5pc01hdGNoID0gKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHBpY29tYXRjaChwYXR0ZXJucywgb3B0aW9ucykoc3RyKTtcblxuLyoqXG4gKiBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICovXG5cbm1pY3JvbWF0Y2guYW55ID0gbWljcm9tYXRjaC5pc01hdGNoO1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIHN0cmluZ3MgdGhhdCBfKipkbyBub3QgbWF0Y2ggYW55KipfIG9mIHRoZSBnaXZlbiBgcGF0dGVybnNgLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIC8vIG1tLm5vdChsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5ub3QoWydhLmEnLCAnYi5iJywgJ2MuYyddLCAnKi5hJykpO1xuICogLy89PiBbJ2IuYicsICdjLmMnXVxuICogYGBgXG4gKiBAcGFyYW0ge0FycmF5fSBgbGlzdGAgQXJyYXkgb2Ygc3RyaW5ncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybiB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCAqKmRvIG5vdCBtYXRjaCoqIHRoZSBnaXZlbiBwYXR0ZXJucy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5ub3QgPSAobGlzdCwgcGF0dGVybnMsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBwYXR0ZXJucyA9IFtdLmNvbmNhdChwYXR0ZXJucykubWFwKFN0cmluZyk7XG4gIGxldCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gIGxldCBpdGVtcyA9IFtdO1xuXG4gIGxldCBvblJlc3VsdCA9IHN0YXRlID0+IHtcbiAgICBpZiAob3B0aW9ucy5vblJlc3VsdCkgb3B0aW9ucy5vblJlc3VsdChzdGF0ZSk7XG4gICAgaXRlbXMucHVzaChzdGF0ZS5vdXRwdXQpO1xuICB9O1xuXG4gIGxldCBtYXRjaGVzID0gbmV3IFNldChtaWNyb21hdGNoKGxpc3QsIHBhdHRlcm5zLCB7IC4uLm9wdGlvbnMsIG9uUmVzdWx0IH0pKTtcblxuICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgaWYgKCFtYXRjaGVzLmhhcyhpdGVtKSkge1xuICAgICAgcmVzdWx0LmFkZChpdGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5yZXN1bHRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBzdHJpbmdgIGNvbnRhaW5zIHRoZSBnaXZlbiBwYXR0ZXJuLiBTaW1pbGFyXG4gKiB0byBbLmlzTWF0Y2hdKCNpc01hdGNoKSBidXQgdGhlIHBhdHRlcm4gY2FuIG1hdGNoIGFueSBwYXJ0IG9mIHRoZSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIHZhciBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIC8vIG1tLmNvbnRhaW5zKHN0cmluZywgcGF0dGVyblssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5jb250YWlucygnYWEvYmIvY2MnLCAnKmInKSk7XG4gKiAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmNvbnRhaW5zKCdhYS9iYi9jYycsICcqZCcpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgIFRoZSBzdHJpbmcgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSBwYXR0ZXJucyBtYXRjaGVzIGFueSBwYXJ0IG9mIGBzdHJgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLmNvbnRhaW5zID0gKHN0ciwgcGF0dGVybiwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhIHN0cmluZzogXCIke3V0aWwuaW5zcGVjdChzdHIpfVwiYCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNvbWUocCA9PiBtaWNyb21hdGNoLmNvbnRhaW5zKHN0ciwgcCwgb3B0aW9ucykpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc0VtcHR5U3RyaW5nKHN0cikgfHwgaXNFbXB0eVN0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHIuaW5jbHVkZXMocGF0dGVybikgfHwgKHN0ci5zdGFydHNXaXRoKCcuLycpICYmIHN0ci5zbGljZSgyKS5pbmNsdWRlcyhwYXR0ZXJuKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaWNyb21hdGNoLmlzTWF0Y2goc3RyLCBwYXR0ZXJuLCB7IC4uLm9wdGlvbnMsIGNvbnRhaW5zOiB0cnVlIH0pO1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgdGhlIGtleXMgb2YgdGhlIGdpdmVuIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgZ2xvYmAgcGF0dGVyblxuICogYW5kIGBvcHRpb25zYC4gRG9lcyBub3QgYXR0ZW1wdCB0byBtYXRjaCBuZXN0ZWQga2V5cy4gSWYgeW91IG5lZWQgdGhpcyBmZWF0dXJlLFxuICogdXNlIFtnbG9iLW9iamVjdF1bXSBpbnN0ZWFkLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIC8vIG1tLm1hdGNoS2V5cyhvYmplY3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IG9iaiA9IHsgYWE6ICdhJywgYWI6ICdiJywgYWM6ICdjJyB9O1xuICogY29uc29sZS5sb2cobW0ubWF0Y2hLZXlzKG9iaiwgJypiJykpO1xuICogLy89PiB7IGFiOiAnYicgfVxuICogYGBgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9iamVjdGAgVGhlIG9iamVjdCB3aXRoIGtleXMgdG8gZmlsdGVyLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBwYXR0ZXJuc2AgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBvbmx5IGtleXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0dGVybnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gubWF0Y2hLZXlzID0gKG9iaiwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIGxldCBrZXlzID0gbWljcm9tYXRjaChPYmplY3Qua2V5cyhvYmopLCBwYXR0ZXJucywgb3B0aW9ucyk7XG4gIGxldCByZXMgPSB7fTtcbiAgZm9yIChsZXQga2V5IG9mIGtleXMpIHJlc1trZXldID0gb2JqW2tleV07XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzb21lIG9mIHRoZSBzdHJpbmdzIGluIHRoZSBnaXZlbiBgbGlzdGAgbWF0Y2ggYW55IG9mIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuc2AuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0uc29tZShsaXN0LCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtbS5zb21lKFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5zb21lKFsnZm9vLmpzJ10sIFsnKi5qcycsICchZm9vLmpzJ10pKTtcbiAqIC8vIGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgbGlzdGAgVGhlIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIHRvIHRlc3QuIFJldHVybnMgYXMgc29vbiBhcyB0aGUgZmlyc3QgbWF0Y2ggaXMgZm91bmQuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYHBhdHRlcm5zYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKSBmb3IgY2hhbmdpbmcgaG93IG1hdGNoZXMgYXJlIHBlcmZvcm1lZFxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBgcGF0dGVybnNgIG1hdGNoZXMgYW55IG9mIHRoZSBzdHJpbmdzIGluIGBsaXN0YFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLnNvbWUgPSAobGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IGl0ZW1zID0gW10uY29uY2F0KGxpc3QpO1xuXG4gIGZvciAobGV0IHBhdHRlcm4gb2YgW10uY29uY2F0KHBhdHRlcm5zKSkge1xuICAgIGxldCBpc01hdGNoID0gcGljb21hdGNoKFN0cmluZyhwYXR0ZXJuKSwgb3B0aW9ucyk7XG4gICAgaWYgKGl0ZW1zLnNvbWUoaXRlbSA9PiBpc01hdGNoKGl0ZW0pKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGV2ZXJ5IHN0cmluZyBpbiB0aGUgZ2l2ZW4gYGxpc3RgIG1hdGNoZXNcbiAqIGFueSBvZiB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtbSA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbiAqIC8vIG1tLmV2ZXJ5KGxpc3QsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKG1tLmV2ZXJ5KCdmb28uanMnLCBbJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKiBjb25zb2xlLmxvZyhtbS5ldmVyeShbJ2Zvby5qcycsICdiYXIuanMnXSwgWycqLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGNvbnNvbGUubG9nKG1tLmV2ZXJ5KFsnZm9vLmpzJywgJ2Jhci5qcyddLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICogY29uc29sZS5sb2cobW0uZXZlcnkoWydmb28uanMnXSwgWycqLmpzJywgJyFmb28uanMnXSkpO1xuICogLy8gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBsaXN0YCBUaGUgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYWxsIGBwYXR0ZXJuc2AgbWF0Y2hlcyBhbGwgb2YgdGhlIHN0cmluZ3MgaW4gYGxpc3RgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guZXZlcnkgPSAobGlzdCwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IGl0ZW1zID0gW10uY29uY2F0KGxpc3QpO1xuXG4gIGZvciAobGV0IHBhdHRlcm4gb2YgW10uY29uY2F0KHBhdHRlcm5zKSkge1xuICAgIGxldCBpc01hdGNoID0gcGljb21hdGNoKFN0cmluZyhwYXR0ZXJuKSwgb3B0aW9ucyk7XG4gICAgaWYgKCFpdGVtcy5ldmVyeShpdGVtID0+IGlzTWF0Y2goaXRlbSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgKiphbGwqKiBvZiB0aGUgZ2l2ZW4gYHBhdHRlcm5zYCBtYXRjaFxuICogdGhlIHNwZWNpZmllZCBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0uYWxsKHN0cmluZywgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnIWZvby5qcyddKSk7XG4gKiAvLyBmYWxzZVxuICpcbiAqIGNvbnNvbGUubG9nKG1tLmFsbCgnZm9vLmpzJywgWycqLmpzJywgJ2Zvby5qcyddKSk7XG4gKiAvLyB0cnVlXG4gKlxuICogY29uc29sZS5sb2cobW0uYWxsKCdmb28uanMnLCBbJyouanMnLCAnZionLCAnKm8qJywgJypvLmpzJ10pKTtcbiAqIC8vIHRydWVcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGBzdHJgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpIGZvciBjaGFuZ2luZyBob3cgbWF0Y2hlcyBhcmUgcGVyZm9ybWVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guYWxsID0gKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHt1dGlsLmluc3BlY3Qoc3RyKX1cImApO1xuICB9XG5cbiAgcmV0dXJuIFtdLmNvbmNhdChwYXR0ZXJucykuZXZlcnkocCA9PiBwaWNvbWF0Y2gocCwgb3B0aW9ucykoc3RyKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlcyBjYXB0dXJlZCBieSBgcGF0dGVybmAgaW4gYHN0cmluZywgb3IgYG51bGxgIGlmIHRoZSBwYXR0ZXJuIGRpZCBub3QgbWF0Y2guXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0uY2FwdHVyZShwYXR0ZXJuLCBzdHJpbmdbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0uY2FwdHVyZSgndGVzdC8qLmpzJywgJ3Rlc3QvZm9vLmpzJykpO1xuICogLy89PiBbJ2ZvbyddXG4gKiBjb25zb2xlLmxvZyhtbS5jYXB0dXJlKCd0ZXN0LyouanMnLCAnZm9vL2Jhci5jc3MnKSk7XG4gKiAvLz0+IG51bGxcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBnbG9iYCBHbG9iIHBhdHRlcm4gdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgIFN0cmluZyB0byBtYXRjaFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykgZm9yIGNoYW5naW5nIGhvdyBtYXRjaGVzIGFyZSBwZXJmb3JtZWRcbiAqIEByZXR1cm4ge0FycmF5fG51bGx9IFJldHVybnMgYW4gYXJyYXkgb2YgY2FwdHVyZXMgaWYgdGhlIGlucHV0IG1hdGNoZXMgdGhlIGdsb2IgcGF0dGVybiwgb3RoZXJ3aXNlIGBudWxsYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWljcm9tYXRjaC5jYXB0dXJlID0gKGdsb2IsIGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIGxldCBwb3NpeCA9IHV0aWxzLmlzV2luZG93cyhvcHRpb25zKTtcbiAgbGV0IHJlZ2V4ID0gcGljb21hdGNoLm1ha2VSZShTdHJpbmcoZ2xvYiksIHsgLi4ub3B0aW9ucywgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhwb3NpeCA/IHV0aWxzLnRvUG9zaXhTbGFzaGVzKGlucHV0KSA6IGlucHV0KTtcblxuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2guc2xpY2UoMSkubWFwKHYgPT4gdiA9PT0gdm9pZCAwID8gJycgOiB2KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybmAuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogLy8gbW0ubWFrZVJlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cobW0ubWFrZVJlKCcqLmpzJykpO1xuICogLy89PiAvXig/OihcXC5bXFxcXFxcL10pPyg/IVxcLikoPz0uKVteXFwvXSo/XFwuanMpJC9cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBBIGdsb2IgcGF0dGVybiB0byBjb252ZXJ0IHRvIHJlZ2V4LlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7UmVnRXhwfSBSZXR1cm5zIGEgcmVnZXggY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLm1ha2VSZSA9ICguLi5hcmdzKSA9PiBwaWNvbWF0Y2gubWFrZVJlKC4uLmFyZ3MpO1xuXG4vKipcbiAqIFNjYW4gYSBnbG9iIHBhdHRlcm4gdG8gc2VwYXJhdGUgdGhlIHBhdHRlcm4gaW50byBzZWdtZW50cy4gVXNlZFxuICogYnkgdGhlIFtzcGxpdF0oI3NwbGl0KSBtZXRob2QuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogY29uc3Qgc3RhdGUgPSBtbS5zY2FuKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5taWNyb21hdGNoLnNjYW4gPSAoLi4uYXJncykgPT4gcGljb21hdGNoLnNjYW4oLi4uYXJncyk7XG5cbi8qKlxuICogUGFyc2UgYSBnbG9iIHBhdHRlcm4gdG8gY3JlYXRlIHRoZSBzb3VyY2Ugc3RyaW5nIGZvciBhIHJlZ3VsYXJcbiAqIGV4cHJlc3Npb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1tID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogY29uc3Qgc3RhdGUgPSBtbS5wYXJzZShwYXR0ZXJuWywgb3B0aW9uc10pO1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGdsb2JgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdXNlZnVsIHByb3BlcnRpZXMgYW5kIG91dHB1dCB0byBiZSB1c2VkIGFzIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2gucGFyc2UgPSAocGF0dGVybnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBwYXR0ZXJuIG9mIFtdLmNvbmNhdChwYXR0ZXJucyB8fCBbXSkpIHtcbiAgICBmb3IgKGxldCBzdHIgb2YgYnJhY2VzKFN0cmluZyhwYXR0ZXJuKSwgb3B0aW9ucykpIHtcbiAgICAgIHJlcy5wdXNoKHBpY29tYXRjaC5wYXJzZShzdHIsIG9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgZ2l2ZW4gYnJhY2UgYHBhdHRlcm5gLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCB7IGJyYWNlcyB9ID0gcmVxdWlyZSgnbWljcm9tYXRjaCcpO1xuICogY29uc29sZS5sb2coYnJhY2VzKCdmb28ve2EsYixjfS9iYXInKSk7XG4gKiAvLz0+IFsgJ2Zvby8oYXxifGMpL2JhcicgXVxuICpcbiAqIGNvbnNvbGUubG9nKGJyYWNlcygnZm9vL3thLGIsY30vYmFyJywgeyBleHBhbmQ6IHRydWUgfSkpO1xuICogLy89PiBbICdmb28vYS9iYXInLCAnZm9vL2IvYmFyJywgJ2Zvby9jL2JhcicgXVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gIFN0cmluZyB3aXRoIGJyYWNlIHBhdHRlcm4gdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2AgQW55IFtvcHRpb25zXSgjb3B0aW9ucykgdG8gY2hhbmdlIGhvdyBleHBhbnNpb24gaXMgcGVyZm9ybWVkLiBTZWUgdGhlIFticmFjZXNdW10gbGlicmFyeSBmb3IgYWxsIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1pY3JvbWF0Y2guYnJhY2VzID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgaWYgKChvcHRpb25zICYmIG9wdGlvbnMubm9icmFjZSA9PT0gdHJ1ZSkgfHwgIS9cXHsuKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBbcGF0dGVybl07XG4gIH1cbiAgcmV0dXJuIGJyYWNlcyhwYXR0ZXJuLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhwYW5kIGJyYWNlc1xuICovXG5cbm1pY3JvbWF0Y2guYnJhY2VFeHBhbmQgPSAocGF0dGVybiwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuICByZXR1cm4gbWljcm9tYXRjaC5icmFjZXMocGF0dGVybiwgeyAuLi5vcHRpb25zLCBleHBhbmQ6IHRydWUgfSk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBtaWNyb21hdGNoXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBtaWNyb21hdGNoO1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiYnJhY2VzIiwicGljb21hdGNoIiwidXRpbHMiLCJpc0VtcHR5U3RyaW5nIiwidmFsIiwibWljcm9tYXRjaCIsImxpc3QiLCJwYXR0ZXJucyIsIm9wdGlvbnMiLCJjb25jYXQiLCJvbWl0IiwiU2V0Iiwia2VlcCIsIml0ZW1zIiwibmVnYXRpdmVzIiwib25SZXN1bHQiLCJzdGF0ZSIsImFkZCIsIm91dHB1dCIsImkiLCJsZW5ndGgiLCJpc01hdGNoIiwiU3RyaW5nIiwibmVnYXRlZCIsIm5lZ2F0ZWRFeHRnbG9iIiwiaXRlbSIsIm1hdGNoZWQiLCJtYXRjaCIsImRlbGV0ZSIsInJlc3VsdCIsIm1hdGNoZXMiLCJmaWx0ZXIiLCJoYXMiLCJmYWlsZ2xvYiIsIkVycm9yIiwiam9pbiIsIm5vbnVsbCIsIm51bGxnbG9iIiwidW5lc2NhcGUiLCJtYXAiLCJwIiwicmVwbGFjZSIsIm1hdGNoZXIiLCJwYXR0ZXJuIiwic3RyIiwiYW55Iiwibm90IiwicHVzaCIsImNvbnRhaW5zIiwiVHlwZUVycm9yIiwiaW5zcGVjdCIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJpbmNsdWRlcyIsInN0YXJ0c1dpdGgiLCJzbGljZSIsIm1hdGNoS2V5cyIsIm9iaiIsImlzT2JqZWN0Iiwia2V5cyIsIk9iamVjdCIsInJlcyIsImtleSIsImV2ZXJ5IiwiYWxsIiwiY2FwdHVyZSIsImdsb2IiLCJpbnB1dCIsInBvc2l4IiwiaXNXaW5kb3dzIiwicmVnZXgiLCJtYWtlUmUiLCJleGVjIiwidG9Qb3NpeFNsYXNoZXMiLCJ2IiwiYXJncyIsInNjYW4iLCJwYXJzZSIsIm5vYnJhY2UiLCJ0ZXN0IiwiYnJhY2VFeHBhbmQiLCJleHBhbmQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/micromatch/index.js\n");

/***/ })

};
;